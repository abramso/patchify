#! /usr/bin/env python
# Note that cfy is used rather than the client so that the user does not have
# to provide credentials, etc, to this script.
import argparse
import datetime
import json
import os
import subprocess
import sys
import time


class VersionError(Exception):
    pass


class UploadError(Exception):
    pass


def exit_with_sadness(message):
    sadly_say(message)
    sadly_say('FAILED TO APPLY PATCH!')
    sys.exit(1)


def say(message):
    print(message)


def sadly_say(message):
    sys.stderr.write('%s\n' % message)


def get_manager_version():
    try:
        version_output = subprocess.check_output(['cfy', '--version'])
    except subprocess.CalledProcessError:
        return None

    community = 'Community edition' in version_output
    version = None

    for line in version_output.splitlines():
        if line.lower().startswith('cloudify manager'):
            # Expecting line to be similar to:
            # Cloudify Manager 4.2.0 [ip=10.239.3.199]
            version = line.split(' ')[2]
            break

    return {
        'version': version,
        'community': community,
    }


def parse_version_string(version):
    """
        Parse a version string in semantic versioning format.
    """
    version = version.split('.')

    if len(version) != 3:
        raise VersionError(
            'Version string must contain three components. '
            'Found: {split_version}'.format(
                split_version=version,
            ),
        )

    try:
        version = tuple(int(part) for part in version)
    except ValueError:
        raise VersionError(
            'Version string must contain only integer components. '
            'Found: {version}'.format(version=version),
        )

    return version


def load_patch_definition(filename):
    # TODO: Load the patch definition straight from the patch zip file
    with open(filename) as definition_handle:
        definition = json.load(definition_handle)

    # As this is a POC, I'm not creating a programmatic way to define schema
    # yet.
    # Currently this only handles version 1.0.0 of patch definitions:
    # {
    #   "patch_version": 1.0.0,  # No other value supported yet
    #   "manager_versions": [4.2],  # List of supported cloudify managers
    #   "community": <true|false>,  # Whether community is supported
    #   "premium": <true|false>,  # Whether premium is supported
    #   "patches": [  # List of patch files to apply.
    #                 # These should be in a format 'patch' on centos
    #                 # understands
    #     {
    #       "patch_file": "<patch file name in patch archive 'patches' dir>",
    #       "md5sum": "<md5sum of patch file>",
    #       "destinations": [  # List of locations that this file should patch
    #         "/path/to/location/on/manager",
    #         "/path/to/other/location/on/manager",
    #       ]
    #     },
    #     ... # More patch files, if any are required
    #   ],
    #   "affected_services": [  # List of services that will be stopped before
    #                           # applying the patches and started afterwards.
    #                           # These services will also be stopped before
    #                           # any rollbacks and started afterwards.
    #     "cloudify-service-1",
    #     "cloudify-service-2"
    #   ],
    #   # Following sections are optional, but recommended
    #   "md5sums_before": {  # Each file will have md5sum checked before
    #                        # applying the patches. If a file on the
    #                        # manager is specified in this list and does not
    #                        # have an md5sum in the acceptable list for that
    #                        # file, the patch process will be aborted.
    #                        # Files in this list will be backed up before the
    #                        # patch is applied, and restored if it aborts for
    #                        # any reason after the initial checks.
    #     "/path/to/file1": ["<md5sum before patch is applied>"],
    #     "/path/to/file2": ["<md5sum before patch is applied>"],
    #     "/path/to/file3": ["<md5sum before patch is applied>",
    #                        "<other acceptable md5sum>"]
    #   },
    #   "md5sums_after": {  # After all commands have been run, these md5sums
    #                       # will be checked after all patches have been
    #                       # applied and will abort and roll back the patch.
    #                       # While the list doesn't have to be the same, it
    #                       # probably should be, usually.
    #     "/path/to/file1": ["<md5sum after patch is applied>"],
    #     "/path/to/file2": ["<md5sum after patch is applied>"],
    #     "/path/to/file3": ["<md5sum after patch is applied>",
    #                        "<other acceptable md5sum>"]
    #   }
    # }
    try:
        patch_version = parse_version_string(definition['patch_version'])
    except KeyError:
        add_definition_error(
            message=(
                'patch_version not found in definition. '
                'Please confirm patch is valid and not corrupted.'
            ),
            definition=definition,
            fatal=True,
        )
        return definition

    if patch_version > (1, 0, 0):
        add_definition_error(
            message=(
                'Only version 1.0.0 patches are supported currently. '
                'Found version: {version}'.format(
                    version='.'.join([str(i) for i in patch_version]),
                )
            ),
            definition=definition,
            fatal=True,
        )
        return definition

    required_keys = ['manager_versions', 'community', 'premium']
    recommended_keys = []
    if patch_version[0] == 1:
        required_keys.extend(['patches', 'affected_services'])
        recommended_keys.extend(['md5sums_before', 'md5sums_after'])

    for key in required_keys:
        if key not in definition:
            add_definition_error(
                message=(
                    'Patch definition must contain {key}. '
                    'Keys found: {found}'.format(
                        key=key,
                        found=', '.join(definition.keys()),
                    )
                ),
                definition=definition,
                fatal=True,
            )

    for key in recommended_keys:
        if key not in definition:
            add_definition_error(
                message=(
                    'Patch definition should contain {key}. '
                    'Keys found: {found}'.format(
                        key=key,
                        found=', '.join(definition.keys()),
                    )
                ),
                definition=definition,
            )

    return definition


def add_definition_error(message, definition, fatal=False):
    errors = definition.get('errors', [])
    errors.append({
        'message': message,
        'fatal': fatal,
    })
    definition['errors'] = errors


def get_unhealthy_services():
    try:
        status_output = subprocess.check_output(['cfy', 'status'])
    except subprocess.CalledProcessError:
        return ['All processes (is cfy pointing at a working manager?)']

    unhealthy_services = []

    dividers_found = 0
    for line in status_output.splitlines():
        if dividers_found == 3:
            # We reached the end of the output
            break

        line = line.strip()

        # Expecting something like:
        # Getting management services status... [ip=192.0.2.4]
        #
        # Services:
        # +--------------------------------+--------+
        # |            service             | status |
        # +--------------------------------+--------+
        # | Riemann                        |   up   |
        # | Celery Management              |   up   |
        # | Manager Rest-Service           |   up   |
        # | AMQP InfluxDB                  |   up   |
        # | RabbitMQ                       |   up   |
        # | Elasticsearch                  |   up   |
        # | Webserver                      |   up   |
        # | Logstash                       |   up   |
        # +--------------------------------+--------+
        if line.startswith('+--'):
            dividers_found += 1
        elif dividers_found == 2:
            # Services are only shown after the second divider
            line = line.split('|')
            service = line[1].strip()
            status = line[2].strip()
            if status not in ('running', 'up'):
                unhealthy_services.append(service)

    return unhealthy_services


def get_file_md5sum(file_path, manager_connection_string):
    # Structure the command so that we return meaningful output in predictable
    # situations (where the path isn't a file (e.g. is a directory) or does
    # not exist), while still allowing failure for unexpected situations
    # (e.g. segfault on one of the commands)
    md5command = (
        'if [[ -f {path} ]]; '
        '  then md5sum {path}; '
        'elif [[ -e {path} ]]; '
        '  then echo -n "{notafile}"; '
        'else '
        '  echo -n "{notexisting}"; '
        'fi'.format(
            path=file_path,
            notafile="NOTAFILE",
            notexisting="DOESNOTEXIST",
        )
    )
    return ssh(manager_connection_string, md5command).split(' ')[0]


def md5sums_match(check_list, manager_connection_string):
    matching = True
    for file_path, acceptable_md5sums in check_list.items():
        say('Checking md5sum for {path}'.format(path=file_path))
        md5sum = get_file_md5sum(file_path, manager_connection_string)

        if md5sum not in acceptable_md5sums:
            matching = False
            if acceptable_md5sums == ["DOESNOTEXIST"]:
                message = (
                    '{file_path} should not exist, but file with md5sum '
                    '{md5sum} was found.'
                )
            else:
                message = (
                    '{file_path} has an incorrect md5sum. '
                    'md5sum was {md5sum}. '
                    'Allowed md5sums are {acceptable}'
                )

            sadly_say(message.format(
                file_path=file_path,
                md5sum=md5sum,
                acceptable=', '.join(acceptable_md5sums),
            ))

    return matching


def can_ssh(manager_connection_string):
    try:
        ssh(manager_connection_string, 'echo "SSH works."')
        return True
    except subprocess.CalledProcessError:
        return False


def patch_command_available(manager_connection_string):
    try:
        ssh(manager_connection_string, 'which patch')
        return True
    except subprocess.CalledProcessError:
        return False


def ssh(manager_connection_string, command):
    return subprocess.check_output(
        ['ssh', manager_connection_string, command]
    )


def stop_services(manager_connection_string, services):
    for service in services:
        ssh(
            manager_connection_string,
            'sudo systemctl stop {service}'.format(service=service),
        )


def start_services(manager_connection_string, services):
    # Ensure we're using any unit files we may have updated
    ssh(
        manager_connection_string,
        'sudo systemctl daemon-reload',
    )
    for service in services:
        ssh(
            manager_connection_string,
            'sudo systemctl start {service}'.format(service=service),
        )


def upload_and_verify_patch_files(manager_connection_string, patches,
                                  staging_dir):
    for patch in patches:
        patch_name = patch['patch_file']
        expected_md5sum = patch['md5sum']
        subprocess.check_call(
            ['scp',
             'patches/{patch}'.format(patch=patch_name),
             '{mgr}:{staging_dir}'.format(
                 mgr=manager_connection_string,
                 staging_dir=staging_dir,
             )]
        )
        uploaded_md5sum = get_file_md5sum(
            file_path=os.path.join(staging_dir, patch_name),
            manager_connection_string=manager_connection_string,
        )

        if not uploaded_md5sum == expected_md5sum:
            raise UploadError(
                'Uploaded {patch} had md5sum {actual}, but should have had '
                '{expected}.'.format(
                    patch=patch_name,
                    actual=uploaded_md5sum,
                    expected=expected_md5sum,
                )
            )


def build_manager_version_output_string(version, community):
    version_output = version
    if community:
        version_output += ' community'
    else:
        version_output += ' premium'
    return version_output


def rollback(manager_connection_string, patch_definition, backup_root,
             delete_root):
    # Make sure all services are stopped, which might not be the case
    # depending on when we had to begin the rollback.
    sadly_say('Ensuring services are stopped for rollback.')
    stop_services(
        manager_connection_string,
        patch_definition['affected_services'],
    )

    sadly_say('Rolling back file changes.')
    affected_files = get_list_of_affected_files(patch_definition['patches'])
    for affected_file in affected_files:
        backed_up_file = os.path.join(
            backup_root,
            affected_file.lstrip('/'),
        )
        delete_dest_parent = os.path.join(
            delete_root,
            os.path.split(affected_file.lstrip('/'))[0]
        )
        delete_dest = os.path.join(
            delete_root,
            affected_file.lstrip('/')
        )
        ssh(
            manager_connection_string,
            'if sudo test -f {backup}; then '    # Only restore existing
            '  sudo cp {backup} {orig}; '        # and remove added files
            'else '
            '  mkdir -p {delete_dest_parent} && '
            '  sudo mv {orig} {delete_dest}; '
            'fi'.format(
                backup=backed_up_file,
                orig=affected_file,
                delete_dest_parent=delete_dest_parent,
                delete_dest=delete_dest,
            ),
        )

    sadly_say('Starting services after rollback.')
    start_services(
        manager_connection_string,
        patch_definition['affected_services'],
    )

    # TODO: We should check service state here

    sadly_say('Rollback complete.')


def get_list_of_affected_files(patches):
    affected_files = []
    for patch in patches:
        affected_files.extend(patch['destinations'])
    return set(affected_files)


def apply_patch(definition_file, manager_connection_string):
    say("Loading patch definition.")
    patch_definition = load_patch_definition(definition_file)

    fatal_error = False
    for error in patch_definition.get('errors', []):
        message = error['message']
        if error['fatal']:
            message = 'FATAL: ' + message
            fatal_error = True
        sadly_say(message)
    if fatal_error:
        exit_with_sadness('Patch definition error!')

    say("Checking manager version is valid.")
    manager_version = get_manager_version()
    if manager_version is None:
        exit_with_sadness(
            'Could not get manager version! '
            'Are you in an environment with cfy using a profile for the '
            'manager you intend to patch?'
        )
    supported_versions = []
    if patch_definition['premium']:
        for version in patch_definition['manager_versions']:
            supported_versions.append({
                'version': version,
                'community': False,
            })
    if patch_definition['community']:
        for version in patch_definition['manager_versions']:
            supported_versions.append({
                'version': version,
                'community': True,
            })
    if manager_version not in supported_versions:
        manager_version_output = manager_version['version']
        manager_version_output = build_manager_version_output_string(
            version=manager_version['version'],
            community=manager_version['community'],
        )
        supported_versions_output = ', '.join([
            build_manager_version_output_string(
                version=version['version'],
                community=version['community'],
            )
            for version in supported_versions
        ])
        exit_with_sadness(
            'Manager version mismatch. '
            'Manager is {manager_version}, but patch only supports '
            '{supported_versions}'.format(
                manager_version=manager_version_output,
                supported_versions=supported_versions_output,
            )
        )

    say("Checking service state.")
    unhealthy_services = get_unhealthy_services()
    if unhealthy_services:
        exit_with_sadness(
            'Not all services are healthy. '
            'Unhealthy services: {services}'.format(
                services=', '.join(unhealthy_services),
            )
        )

    say("Checking SSH.")
    if not can_ssh(manager_connection_string):
        exit_with_sadness(
            'Failed to SSH into manager.',
        )

    say('Confirming patch command exists on server.')
    if not patch_command_available(manager_connection_string):
        exit_with_sadness(
            'Could not find "patch" command on server. '
            'On the manager, you may need to run: sudo yum install -y patch'
        )

    say("Checking md5sums are as expected.")
    if not md5sums_match(patch_definition['md5sums_before'],
                         manager_connection_string):
        exit_with_sadness(
            'Unexpected md5sums found before starting patch installation.'
        )

    # Avoiding : in timestamp to avoid needing to escape it for bash
    timestamp = datetime.datetime.now().strftime('%Y-%m-%dT%H-%M-%S%z')
    say("Patching timestamp is: {timestamp}".format(timestamp=timestamp))

    backup_root = '~/cloudifypatch/{timestamp}/backups'.format(
        timestamp=timestamp,
    )
    delete_root = '~/cloudifypatch/{timestamp}/deleted_files'.format(
        timestamp=timestamp,
    )
    say("Backing up affected files to {path}".format(path=backup_root))
    ssh(
        manager_connection_string,
        'mkdir -p ' + backup_root,
    )
    ssh(
        manager_connection_string,
        'mkdir -p ' + delete_root,
    )
    affected_files = get_list_of_affected_files(patch_definition['patches'])
    for affected_file in affected_files:
        say("Backing up {file_path} to {destination}".format(
            file_path=affected_file,
            destination=os.path.join(
                backup_root,
                affected_file.lstrip('/'),
            ),
        ))
        # We sudo (root) the copy because of user differences in different
        # versions of cloudify, but we probably should define this better
        # based on which version it's targetting.
        ssh(
            manager_connection_string,
            'if sudo test -f {source}; then '  # Only if the file exists
            'sudo cp --parents {source} {destination}; fi'.format(
                source=affected_file,
                destination=backup_root,
            ),
        )

    staging_dir = '~/cloudifypatch/{timestamp}/patches'.format(
        timestamp=timestamp,
    )
    ssh(
        manager_connection_string,
        'mkdir -p ' + staging_dir,
    )
    say("Uploading and verifying patch files.")
    try:
        upload_and_verify_patch_files(manager_connection_string,
                                      patch_definition['patches'],
                                      staging_dir)
    except UploadError as err:
        exit_with_sadness(
            'Failed to upload patch files: {err}'.format(
                err=str(err),
            )
        )

    say("Stopping services.")
    stop_services(manager_connection_string,
                  patch_definition['affected_services'])

    say("Applying patches.")
    for patch in patch_definition['patches']:
        for destination in patch['destinations']:
            say(
                'Applying {patch} to {target}'.format(
                    patch=patch['patch_file'],
                    target=destination,
                )
            )
            try:
                ssh(
                    manager_connection_string,
                    'sudo patch {destination} {patch}'.format(
                        destination=destination,
                        patch=os.path.join(
                            staging_dir,
                            patch['patch_file'],
                        ),
                    )
                )
            except subprocess.CalledProcessError as err:
                rollback(manager_connection_string, patch_definition,
                         backup_root, delete_root)
                exit_with_sadness(
                    'Failed to apply patch {patch} to {target}\n'
                    'Changes rolled back.'.format(
                        patch=patch['patch_file'],
                        target=destination,
                    )
                )

    say("Checking post-patch md5sums.")
    if not md5sums_match(patch_definition['md5sums_after'],
                         manager_connection_string):
        rollback(manager_connection_string, patch_definition, backup_root,
                 delete_root)
        exit_with_sadness(
            'Unexpected md5sums found after patch installation.\n'
            'Changes rolled back.'
        )

    say("Starting services.")
    start_services(manager_connection_string,
                   patch_definition['affected_services'])

    say("Checking service state with patches applied.")
    unhealthy_services = []
    for attempt in range(0, 10):
        if unhealthy_services:
            say("Services still restarting...")
            time.sleep(3)
        unhealthy_services = get_unhealthy_services()
    if unhealthy_services:
        rollback(manager_connection_string, patch_definition, backup_root,
                 delete_root)
        exit_with_sadness(
            'Services did not restart correctly. '
            'Unhealthy services: {services}\n'
            'Changes rolled back.'.format(
                services=', '.join(unhealthy_services),
            )
        )

    say('Patch applied!')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Apply a patch to a cloudify manager.',
    )
    # TODO: We should probably want the patch supplied as a zip containing
    # the patch definition and the patch file, but for POC purposes we just
    # put everything in the POC folder

    parser.add_argument(
        '-c', '--manager_connection_string',
        help="The manager connection string for ssh, e.g. centos@192.0.2.4",
        required=True,
    )
    parser.add_argument(
        '-p', '--patch_file',
        help=(
            'The patch file to use. Note that for POC purposes this is just '
            'a definition file, but this should probably be changed to a zip '
            'for real world use (so that it can work on Windows as well as '
            'Linux.'
        ),
        required=True,
    )

    args = parser.parse_args()

    apply_patch(args.patch_file, args.manager_connection_string)
