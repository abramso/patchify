#! /usr/bin/env python
# Note that cfy is used rather than the client so that the user does not have
# to provide credentials, etc, to this script.
import datetime
import json
import os
import subprocess
import sys


class VersionError(Exception):
    pass


# Manually tested
def exit_with_sadness(message):
    sadly_say(message)
    sadly_say('FAILED TO APPLY PATCH!')
    sys.exit(1)


# Manually tested
def say(message):
    print(message)


# Manually tested
def sadly_say(message):
    sys.stderr.write('%s\n' % message)


def get_manager_version():
    try:
        version_output = subprocess.check_output(['cfy', '--version'])
    except subprocess.CalledProcessError:
        return None


    community = 'Community edition' in version_output
    version = None

    for line in version_output.splitlines():
        if line.lower().startswith('cloudify manager'):
            # Expecting line to be similar to:
            # Cloudify Manager 4.2.0 [ip=10.239.3.199]
            version = line.split(' ')[2]
            break

    return {
        'version': version,
        'community': community,
    }


# Manually tested
def parse_version_string(version):
    """
        Parse a version string in semantic versioning format.
    """
    version = version.split('.')

    if len(version) != 3:
        raise VersionError(
            'Version string must contain three components. '
            'Found: {split_version}'.format(
                split_version=version,
            ),
        )

    try:
        version = tuple(int(part) for part in version)
    except ValueError:
        raise VersionError(
            'Version string must contain only integer components. '
            'Found: {version}'.format(version=version),
        )

    return version


def load_patch_definition(filename):
    # TODO: Load the patch definition straight from the patch zip file
    with open(filename) as definition_handle:
        definition = json.load(definition_handle)

    # As this is a POC, I'm not creating a programmatic way to define schema
    # yet.
    # Currently this only handles version 1.0.0 of patch definitions:
    # {
    #   "patch_version": 1.0.0,  # No other value supported yet
    #   "manager_versions": [4.2],  # List of supported cloudify managers
    #   "community": <true|false>,  # Whether community is supported
    #   "premium": <true|false>,  # Whether premium is supported
    #   "patches": [  # List of patch files to apply.
    #                 # These should be in a format 'patch' on centos
    #                 # understands
    #     {
    #       "patch_file": "<patch file name in patch archive 'patches' dir>",
    #       "md5sum": "<md5sum of patch file>",
    #       "destinations": [  # List of locations that this file should patch
    #         "/path/to/location/on/manager",
    #         "/path/to/other/location/on/manager",
    #       ]
    #     },
    #     ... # More patch files, if any are required
    #   ],
    #   "affected_services": [  # List of services that will be stopped before
    #                           # applying the patches and started afterwards.
    #                           # These services will also be stopped before
    #                           # any rollbacks and started afterwards.
    #     "cloudify-service-1",
    #     "cloudify-service-2"
    #   ],
    #   # Following sections are optional, but recommended
    #   "md5sums_before": {  # Each file will have md5sum checked before
    #                        # applying the patches. If a file on the
    #                        # manager is specified in this list and does not
    #                        # have an md5sum in the acceptable list for that
    #                        # file, the patch process will be aborted.
    #                        # Files in this list will be backed up before the
    #                        # patch is applied, and restored if it aborts for
    #                        # any reason after the initial checks.
    #     "/path/to/file1": ["<md5sum before patch is applied>"],
    #     "/path/to/file2": ["<md5sum before patch is applied>"],
    #     "/path/to/file3": ["<md5sum before patch is applied>",
    #                        "<other acceptable md5sum>"]
    #   },
    #   "md5sums_after": {  # After all commands have been run, these md5sums
    #                       # will be checked after all patches have been
    #                       # applied and will abort and roll back the patch.
    #                       # While the list doesn't have to be the same, it
    #                       # probably should be, usually.
    #     "/path/to/file1": ["<md5sum after patch is applied>"],
    #     "/path/to/file2": ["<md5sum after patch is applied>"],
    #     "/path/to/file3": ["<md5sum after patch is applied>",
    #                        "<other acceptable md5sum>"]
    #   }
    # }
    try:
        patch_version = parse_version_string(definition['patch_version'])
    except KeyError:
        add_definition_error(
            message=(
                'patch_version not found in definition. '
                'Please confirm patch is valid and not corrupted.'
            ),
            definition=definition,
            fatal=True,
        )
        return definition

    if patch_version > (1,0,0):
        add_definition_error(
            message=(
                'Only version 1.0.0 patches are supported currently. '
                'Found version: {version}'.format(
                    version='.'.join([str(i) for i in patch_version]),
                )
            ),
            definition=definition,
            fatal=True,
        )
        return definition

    required_keys = ['manager_versions', 'community', 'premium']
    recommended_keys = []
    if patch_version[0] == 1:
        required_keys.extend(['patches', 'affected_services'])
        recommended_keys.extend(['md5sums_before', 'md5sums_after'])

    for key in required_keys:
        if key not in definition:
            add_definition_error(
                message=(
                    'Patch definition must contain {key}. '
                    'Keys found: {found}'.format(
                        key=key,
                        found=', '.join(definition.keys()),
                    )
                ),
                definition=definition,
                fatal=True,
            )

    for key in recommended_keys:
        if key not in definition:
            add_definition_error(
                message=(
                    'Patch definition should contain {key}. '
                    'Keys found: {found}'.format(
                        key=key,
                        found=', '.join(definition.keys()),
                    )
                ),
                definition=definition,
            )

    return definition


def add_definition_error(message, definition, fatal=False):
    errors =  definition.get('errors', [])
    errors.append({
        'message': message,
        'fatal': fatal,
    })
    definition['errors'] = errors

# Manually tested
def get_unhealthy_services():
    try:
        status_output = subprocess.check_output(['cfy', 'status'])
    except subprocess.CalledProcessError:
        return ['All processes (is cfy pointing at a working manager?)']

    unhealthy_services = []

    dividers_found = 0
    for line in status_output.splitlines():
        if dividers_found == 3:
            # We reached the end of the output
            break

        line = line.strip()

        # Expecting something like:
        # Getting management services status... [ip=192.0.2.4]
        # 
        # Services:
        # +--------------------------------+--------+
        # |            service             | status |
        # +--------------------------------+--------+
        # | Riemann                        |   up   |
        # | Celery Management              |   up   |
        # | Manager Rest-Service           |   up   |
        # | AMQP InfluxDB                  |   up   |
        # | RabbitMQ                       |   up   |
        # | Elasticsearch                  |   up   |
        # | Webserver                      |   up   |
        # | Logstash                       |   up   |
        # +--------------------------------+--------+
        if line.startswith('+--'):
            dividers_found += 1
        elif dividers_found == 2:
            # Services are only shown after the second divider
            line = line.split('|')
            service = line[1].strip()
            status = line[2].strip()
            if status not in ('running', 'up'):
                unhealthy_services.append(service)

    return unhealthy_services


# Manually tested
def get_file_md5sum(file_path, manager_connection_string):
    # Structure the command so that we return meaningful output in predictable
    # situations (where the path isn't a file (e.g. is a directory) or does
    # not exist), while still allowing failure for unexpected situations
    # (e.g. segfault on one of the commands)
    md5command = (
        'if [[ -f {path} ]]; '
        '  then md5sum {path}; '
        'elif [[ -e {path} ]]; '
        '  then echo -n "{notafile}"; '
        'else '
        '  echo -n "{notexisting}"; '
        'fi'.format(
            path=file_path,
            notafile="NOTAFILE",
            notexisting="DOESNOTEXIST",
        )
    )
    return ssh(manager_connection_string, md5command).split(' ')[0]


# Manually tested
def md5sums_match(check_list, manager_connection_string):
    matching = True
    for file_path, acceptable_md5sums in check_list.items():
        say('Checking md5sum for {path}'.format(path=file_path))
        md5sum = get_file_md5sum(file_path, manager_connection_string)

        if md5sum not in acceptable_md5sums:
            matching = False
            sadly_say(
                '{file_path} has an incorrect md5sum. '
                'md5sum was {md5sum}. '
                'Allowed md5sums are {acceptable}'.format(
                    file_path=file_path,
                    md5sum=md5sum,
                    acceptable=', '.join(acceptable_md5sums),
                )
            )

    return matching


# Manually tested
def can_ssh(manager_connection_string):
    try:
        ssh(manager_connection_string, 'echo "SSH works."')
        return True
    except subprocess.CalledProcessError:
        return False

# Check manager version (done)

# Check service status (done)

# Check SSH is working (done)

# Check md5sums; on fail, abort (done)

# Backup existing files (done)

# Stop services

# Apply specified patches

# Check md5sums; on fail, restore backup, restart services, and abort

# Start services

# Check service status; on fail, restore backup, restart services, and abort

# Finished!



def ssh(manager_connection_string, command):
    return subprocess.check_output(
        ['ssh', manager_connection_string, command]
    )


# Manually tested
def build_manager_version_output_string(version, community):
    version_output = version
    if community:
        version_output += ' community'
    else:
        version_output += ' premium'
    return version_output


def main(definition_file, manager_connection_string):
    say("Loading patch definition.")
    patch_definition = load_patch_definition(definition_file)

    fatal_error = False
    for error in patch_definition.get('errors', []):
        message = error['message']
        if error['fatal']:
            message = 'FATAL: ' + message
            fatal_error = True
        sadly_say(message)
    if fatal_error:
        exit_with_sadness('Patch definition error!')

    say("Checking manager version is valid.")
    manager_version = get_manager_version()
    if manager_version is None:
        exit_with_sadness(
            'Could not get manager version! '
            'Are you in an environment with cfy using a profile for the '
            'manager you intend to patch?'
        )
    supported_versions = []
    if patch_definition['premium']:
        for version in patch_definition['manager_versions']:
            supported_versions.append({
                'version': version,
                'community': False,
            })
    if patch_definition['community']:
        for version in patch_definition['manager_versions']:
            supported_versions.append({
                'version': version,
                'community': True,
            })
    if manager_version not in supported_versions:
        manager_version_output = manager_version['version']
        manager_version_output = build_manager_version_output_string(
            version=manager_version['version'],
            community=manager_version['community'],
        )
        supported_versions_output = ', '.join([
            build_manager_version_output_string(
                version=version['version'],
                community=version['community'],
            )
            for version in supported_versions
        ])
        exit_with_sadness(
            'Manager version mismatch. '
            'Manager is {manager_version}, but patch only supports '
            '{supported_versions}'.format(
                manager_version=manager_version_output,
                supported_versions=supported_versions_output,
            )
        )

    say("Checking service state.")
    unhealthy_services = get_unhealthy_services()
    if unhealthy_services:
        exit_with_sadness(
            'Not all services are healthy. '
            'Unhealthy services: {services}'.format(
                services=', '.join(unhealthy_services),
            )
        )

    say("Checking SSH.")
    if not can_ssh(manager_connection_string):
        exit_with_sadness(
            'Failed to SSH into manager.',
        )

    say("Checking md5sums are as expected.")
    if not md5sums_match(patch_definition['md5sums_before'],
                         manager_connection_string):
        exit_with_sadness(
            'Unexpected md5sums found before starting patch installation.'
        )

    timestamp = datetime.datetime.now().strftime('%Y-%m-%dT%H-%M-%S')
    say("Patching timestamp is: {timestamp}".format(timestamp=timestamp))

    backup_root = '~/cloudifypatch/{timestamp}/backups'.format(
        timestamp=timestamp,
    )
    say("Backing up affected files to {path}".format(path=backup_root))
    ssh(
        manager_connection_string,
        'mkdir -p ' + backup_root,
    )
    affected_files = []
    for patch in patch_definition['patches']:
        affected_files.extend(patch['destinations'])
    affected_files = set(affected_files)
    for affected_file in affected_files:
        say("Backing up {file_path} to {destination}".format(
            file_path=affected_file,
            destination=os.path.join(
                backup_root,
                affected_file.lstrip('/'),
            ),
        ))
        # We sudo (root) the copy because of user differences in different
        # versions of cloudify, but we probably should define this better
        # based on which version it's targetting.
        ssh(
            manager_connection_string,
            'sudo cp --parents {source} {destination}'.format(
                source=affected_file,
                destination=backup_root,
           ),
        )

if __name__ == '__main__':
    # TODO: Need manager ssh connection string
    # TODO: Need patch file path (make it a zip, extract in tempdir, check definition.json?)
    # TODO: Don't provide a patch definitions filename, provide a patch archive
    main('testdef.json', 'centos@10.239.3.199')
