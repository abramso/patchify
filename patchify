#! /usr/bin/env python
# Note that cfy is used rather than the client so that the user does not have
# to provide credentials, etc, to this script.
import json
import subprocess
import sys


class VersionError(Exception):
    pass


# Manually tested
def exit_with_sadness(message):
    sadly_say(message)
    sadly_say('FAILED TO APPLY PATCH!')
    sys.exit(1)


# Manually tested
def say(message):
    print(message)


# Manually tested
def sadly_say(message):
    sys.stderr.write('%s\n' % message)


# Manually tested
def get_manager_version():
    version_output = subprocess.check_output(['cfy', '--version'])

    version = None
    for line in version_output.splitlines():
        if line.lower().startswith('cloudify manager'):
            # Expecting line to be similar to:
            # Cloudify Manager 4.2.0 [ip=10.239.3.199]
            version = line.split(' ')[2]
            break

    return version


# Manually tested
def parse_version_string(version):
    """
        Parse a version string in semantic versioning format.
    """
    version = version.split('.')

    if len(version) != 3:
        raise VersionError(
            'Version string must contain three components. '
            'Found: {split_version}'.format(
                split_version=version,
            ),
        )

    try:
        version = tuple(int(part) for part in version)
    except ValueError:
        raise VersionError(
            'Version string must contain only integer components. '
            'Found: {version}'.format(version=version),
        )

    return version


def load_patch_definition(filename):
    # TODO: Load the patch definition straight from the patch zip file
    with open(filename) as definition_handle:
        definition = json.load(definition_handle)

    # As this is a POC, I'm not creating a programmatic way to define schema
    # yet.
    # Currently this only handles version 1.0.0 of patch definitions:
    # {
    #   "patch_version": 1.0.0,  # No other value supported yet
    #   "manager_versions": [4.2],  # List of supported cloudify managers
    #   "patches": [
    #     {
    #       "patch_file": "<relative path to patch file in patch archive>",  # TODO: Force these to be in a patches dir for future-proofing
    #       "md5sum": "<md5sum of patch file>",
    #       "destinations": [
    #         
    #       ]
    #     },
    #     # TODO: Example showing valency is allowed to be greater than 1
    #   ],
    #   "affected_services": [  # List of services that will be stopped before
    #                           # applying the patches and started afterwards.
    #                           # These services will also be stopped before
    #                           # any rollbacks and started afterwards.
    #     "cloudify-service-1",
    #     "cloudify-service-2"
    #   ],
    #   # Following sections are optional, but recommended
    #   "md5sums_before": {  # Each file will have md5sum checked before
    #                        # applying the patch commands. If a file on the
    #                        # manager is specified in this list and does not
    #                        # have an md5sum in the acceptable list for that
    #                        # file, the patch process will be aborted.
    #                        # Files in this list will be backed up before the
    #                        # patch is applied, and restored if it aborts for
    #                        # any reason after the initial checks.
    #     "/path/to/file1": ["<md5sum before patch is applied>"],
    #     "/path/to/file2": ["<md5sum before patch is applied>"],
    #     "/path/to/file3": ["<md5sum before patch is applied>",
    #                        "<other acceptable md5sum>"]
    #   },
    #   "md5sums_after": {  # After all commands have been run, these md5sums
    #                       # will be checked after all commands have been run
    #                       # and will abort and roll back the patch.
    #                       # While the list doesn't have to be the same, it
    #                       # probably should be, usually.
    #     "/path/to/file1": ["<md5sum after patch is applied>"],
    #     "/path/to/file2": ["<md5sum after patch is applied>"],
    #     "/path/to/file3": ["<md5sum after patch is applied>",
    #                        "<other acceptable md5sum>"]
    #   }
    # }
    patch_version = parse_version_string(definition['patch_version'])

    if patch_version >= (2,0,0):
        add_definition_error(
            message=(
                'Only version 1.x.y patches are supported currently. '
                'Found version: {version}'.format(
                    version='.'.join(patch_version),
                )
            ),
            definition=definition,
            fatal=True,
        )
        return
    elif patch_version > (1,0,0):
        add_definition_error(
            message=(
                'Only version 1.0.0 is fully supported. Features from later '
                'versions of the patch definition will be ignored.'
            ),
            definition=definition,
        )

    required_keys = ['manager_version']
    recommended_keys = []
    if patch_version[0] == 1:
        required_keys.append('commands')
        recommended_keys.extend(['md5sums_before', 'md5sums_after'])

    for key in required_keys:
        if key not in definition:
            add_definition_error(
                message=(
                    'Patch definition must contain {key}, but does not. '
                    'Keys found: {found}'.format(
                        key=key,
                        found=', '.join(definition.keys()),
                    )
                ),
                definition=definition,
                fatal=True,
            )

    for key in recommended_keys:
        if key not in definition:
            add_definition_error(
                message=(
                    'Patch definition should contain {key}, but does not. '
                    'Keys found: {found}'.format(
                        key=key,
                        found=', '.join(definition.keys()),
                    )
                ),
                definition=definition,
            )

    return definition


def add_definition_error(message, definition, fatal=False):
    definition['errors'] = definition.get('errors', []).append({
        'message': message,
        'fatal': fatal,
    })


# Manually tested
def get_unhealthy_services():
    try:
        status_output = subprocess.check_output(['cfy', 'status'])
    except subprocess.CalledProcessError:
        return ['All processes (is cfy pointing at a working manager?)']

    unhealthy_services = []

    dividers_found = 0
    for line in status_output.splitlines():
        if dividers_found == 3:
            # We reached the end of the output
            break

        line = line.strip()

        # Expecting something like:
        # Getting management services status... [ip=192.0.2.4]
        # 
        # Services:
        # +--------------------------------+--------+
        # |            service             | status |
        # +--------------------------------+--------+
        # | Riemann                        |   up   |
        # | Celery Management              |   up   |
        # | Manager Rest-Service           |   up   |
        # | AMQP InfluxDB                  |   up   |
        # | RabbitMQ                       |   up   |
        # | Elasticsearch                  |   up   |
        # | Webserver                      |   up   |
        # | Logstash                       |   up   |
        # +--------------------------------+--------+
        if line.startswith('+--'):
            dividers_found += 1
        elif dividers_found == 2:
            # Services are only shown after the second divider
            line = line.split('|')
            service = line[1].strip()
            status = line[2].strip()
            if status not in ('running', 'up'):
                unhealthy_services.append(service)

    return unhealthy_services


# Manually tested
def get_file_md5sum(file_path, manager_connection_string):
    # Structure the command so that we return meaningful output in predictable
    # situations (where the path isn't a file (e.g. is a directory) or does
    # not exist), while still allowing failure for unexpected situations
    # (e.g. segfault on one of the commands)
    md5command = (
        'if [[ -f {path} ]]; '
        '  then md5sum {path}; '
        'elif [[ -e {path} ]]; '
        '  then echo -n "{notafile}"; '
        'else '
        '  echo -n "{notexisting}"; '
        'fi'.format(
            path=file_path,
            notafile="NOTAFILE",
            notexisting="DOESNOTEXIST",
        )
    )
    return subprocess.check_output([
        'ssh', manager_connection_string, md5command,
    ]).split(' ')[0]


# Manually tested
def md5sums_match(check_list, manager_connection_string):
    matching = True
    for file_path, acceptable_md5sums in check_list.items():
        say('Checking md5sum for {path}'.format(path=file_path))
        md5sum = get_file_md5sum(file_path, manager_connection_string)

        if md5sum not in acceptable_md5sums:
            matching = False
            sadly_say(
                '{file_path} has an incorrect md5sum. '
                'md5sum was {md5sum}. '
                'Allowed md5sums are {acceptable}'.format(
                    file_path=file_path,
                    md5sum=md5sum,
                    acceptable=', '.join(acceptable_md5sums),
                )
            )

    return matching

# Check manager version (done)

# Check service status (done)

# Check md5sums; on fail, abort (done)

# Backup existing files

# Apply specified commands

# Check md5sums; on fail, restore backup, restart services, and abort

# Restart services

# Check service status; on fail, restore backup, restart services, and abort

# Finished!

def main(definition_file, manager_connection_string):
    patch_definition = load_patch_definition(definition_file)

    fatal_error = False
    for error in patch_definition.get('errors', []):
        sadly_say(error['message'])
        if error['fatal']:
            sadly_say('Fatal error.')
            fatal_error = True
            # But we'll display any other errors anyway, so that they can all
            # be fixed, so don't exit early.
    if fatal_error:
        exit_with_sadness('Patch definition error!')

    manager_version = get_manager_version()
    supported_versions = patch_definition['manager_version']
    if manager_version not in supported_versions:
        exit_with_sadness(
            'Manager version mismatch. '
            'Manager is {manager_version}, but patch only supports '
            '{supported_versions}'.format(
                manager_version=manager_version,
                supported_versions=', '.join(supported_versions),
            )
        )

    unhealthy_services = get_unhealthy_services()
    if unhealthy_services:
        exit_with_sadness(
            'Not all services are healthy. '
            'Unhealthy services: {services}'.format(
                services=', '.join(unhealthy_services),
            )
        )

    if not md5sums_match(patch_definition['md5sums_before'],
                         manager_connection_string):
        exit_with_sadness(
            'Unexpected md5sums found before starting patch installation.'
        )

if __name__ == '__main__':
    print(get_unhealthy_services())
    exit_with_sadness('Going, going, gone')
    print('more, you should not see this')
    # TODO: Need manager ssh connection string
    # TODO: Need patch file path (make it a zip, extract in tempdir, check definition.json?)
    # TODO: Don't provide a patch definitions filename, provide a patch archive
    #main('testdef.json', 'centos@10.239.3.199')
